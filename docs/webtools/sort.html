<!DOCTYPE html>
<html lang=”en”>

<head>
  <title>Sort Lines</title>
  <meta charset="utf-8">
  <link rel="stylesheet" href="css/main.css">
  <script src="js/lib.js"></script>
</head>

<body>
  <h1>Sort Lines</h1>
  <label for="key">Key RegExp:&nbsp;</label><input type="text" id="key" size=50>ex.: keyvalue:[A-Z0-9]{16}<br>
  <label for="sep">Seperator RegExp:&nbsp;</label><input type="text" id="sep" size=50>ex.: [,;]<br>
  <label for="range">Key Range:&nbsp;</label><input type="text" id="range" size=50>ex.: 4n,5-7n,1<br>
  <label for="comma">Numeric comma:&nbsp;</label>
  <select id="comma">
    <option value="," selected="selected">European (,)</option>
    <option value=".">American (.)</option>
  </select><br>
  <input type="checkbox" id="inverse">Inverse order<br>
  <input type="checkbox" id="ic">Ignore case<br>
  <input type="checkbox" id="unique">Unique lines only
</body>
<script>
  function run() {
    let lines = [], re, key = gV("key"), sep = gV("sep"), range = gV("range"), reopt = gC("ic") ? "igd" : "gd"

    // basic input value checks
    if (key != "" && sep != "") { sErr(["key", "sep"]); return }
    sOK(["key", "sep"])
    if (range != "" && sep == "" && key == "") { key = "." }
    if (key != "") { try { re = new RegExp(key, reopt); } catch (e) { sErr("key"); return; }; }
    if (sep != "") { try { re = new RegExp(sep, reopt); } catch (e) { sErr("sep"); return; }; }

    // determine key values for each line -> lines array
    let alllines = gV("intext").split('\n')
    if (gC("unique")) { alllines = [... new Set(alllines)] }
    alllines.map(line => {
      let allkeys = [], linekey = "", match
      if (key != "") { allkeys = line.match(re) || []; }
      if (sep != "") {
        let previd = 0
        while (match = re.exec(line)) {
          allkeys.push(line.slice(previd, match.indices[0][0]))
          previd = match.indices[0][1]
        }
        allkeys.push(line.slice(previd, line.length + 1))
      }

      range = range.replace(/[^0-9,-n]/g, '')
      linekey = ""
      if (range == "") {
        (key == "" && sep == "") ? linekey = line : linekey = allkeys.join('')
      } else {
        let end, start
        range.split(",").forEach(r => {
          let dashpos = r.indexOf("-"), num = (r.slice(-1) == "n")
          if (dashpos == -1) {
            end = start = parseInt(r.slice(0, num ? -1 : 10000))
          } else {
            start = parseInt(r.slice(0, dashpos))
            end = parseInt(r.slice(dashpos + 1, num ? -1 : 10000))
          }
          for (let i = start; i <= end; i++) {
            let key = allkeys[i - 1] ?? ""
            if (num) { // numerify the field -> remove all non numeric stuff (except "comma") - then add zeroes to start so we have 30 digits up to end or first "comma"
              key = key.replace(/[^0-9,.]/g, '') // only digits and , and .
              key = (gV("comma") == ",") ? key.replace(/\./g, '') : key.replace(/,/g, '')
              compos = key.indexOf(gV("comma"))
              key = '0'.repeat(Math.max(0, 30 - ((compos == -1) ? key.length : compos))) + key
            }
            linekey += key
          }
        })
      }
      if (gC("ic")) { linekey = linekey.toUpperCase() }
      lines.push({ l: line, k: linekey })
    });

    // sort lines based on key k in lines array
    gE("outtext").value = lines.sort(function (a, b) {
      let x = a.k, y = b.k
      if (gC("inverse")) { [x, y] = [y, x] }
      return ((x < y) ? -1 : ((x > y) ? 1 : 0))
    }).map(l => l.l).join("\n")
  }
  doSetup(run, [10, 100], [10, 100])
</script>

</html>