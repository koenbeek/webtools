<!DOCTYPE html>
<html lang=”en”>

<head>
  <title>Sort Lines</title>
  <script src="js/lib.js"></script>
</head>

<body>
  <h1>Sort Lines</h1>
  <label>Key RegExp:&nbsp;<input type="text" id="key" size=50>ex.: keyvalue:[A-Z0-9]{16}</label><br>
  <label>Seperator RegExp:&nbsp;<input type="text" id="sep" size=50>ex.: [,;]</label><br>
  <label>Key Range:&nbsp;<input type="text" id="range" size=50>ex.: 4n,5-7n,1</label><br>
  <label>Numeric comma:&nbsp;
    <select id="comma">
      <option value="," selected="selected">European (,)</option>
      <option value=".">American (.)</option>
    </select>
  </label><br>
  <label><input type="checkbox" id="inv">Inverse order<br></label>
  <label><input type="checkbox" id="ic">Ignore case<br></label>
  <label><input type="checkbox" id="unique">Unique lines only</label>
</body>
<script>
  function run() {
    let lines = [], re, key = gV("key"), sep = gV("sep"), range = gV("range"), comma = gV("comma"), reopt = gC("ic") ? "igd" : "gd"

    // basic input value checks
    if (key != "" && sep != "") { sErr(["key", "sep"]); return }; sOK(["key", "sep"]) // can't have key and sep regexp at same time
    if (range != "" && sep == "" && key == "") { key = "." } // no key nor sep but a range is specified ? -> each character is a key
    try { re = new RegExp(key != "" ? key : sep, reopt) } catch (e) { sErr(key != "" ? "key" : "sep", e); return }

    // determine key values for each line -> lines array
    let inlines = gV("itxt").split('\n')
    if (gC("unique")) { inlines = [... new Set(inlines)] }
    inlines.map(l => { // for each input line ...
      let allkeys = [], m // determine all the key values for this line l based on sep or key regex
      if (key != "") { allkeys = l.match(re) || [] }
      if (sep != "") { for (var s = 0; m = re.exec(l); allkeys.push(l.slice(s, m.indices[0][0])), s = m.indices[0][1]); allkeys.push(l.slice(s)) }

      range = range.replace(/[^0-9,n-]/g, '') // remove invalid characters from range input
      let sortkey = "" // this "key" will be used to sort the lines on (it's actually just a string composed of all keys seperated by & null char)
      if (range == "") { // no range -> take all keys from 1 to end or full line value if no keys (i.e. no key nor sep regex specified)
        (key == "" && sep == "") ? sortkey = l : sortkey = allkeys.join("\0")
      } else { // determine start and end key nbrs for each key sort range (seperated by dashes '-') and determine sort options : n = numeric
        let start, end
        range.split(",").forEach(r => { // for each keyrange
          let dash = r.indexOf("-"), num = (r.slice(-1) == "n") // '-' position and numeric sort flag
          if (dash == -1) { end = start = parseInt(r.slice(0, num ? -1 : 99999)) } // no range just 1 key -> start = end
          else { start = parseInt(r.slice(0, dash)); end = parseInt(r.slice(dash + 1, num ? -1 : 99999)) } // range of keys from start to end
          for (let k = start; k <= end; k++) { // for each key in the range - add keyvalue to sortkey
            let key = allkeys[k - 1] ?? ""
            if (num) { // numerify the field -> remove all non numeric stuff (except "comma") - then add zeroes to start and end 
              key = key.replace(/[^0-9,.]/g, '').replace(comma == "," ? "." : ",", '') // only digits and our "comma"
              c = key.indexOf(comma)
              prefix = '0'.repeat(Math.max(0, 30 - ((c == -1) ? key.length : c))) // 30 digits before "comma"
              postfix = c == -1 ? comma + '0'.repeat(30) : '0'.repeat(Math.max(0, 31 - key.length + c)) // 30 digits after "comma"
              key = prefix + key + postfix // align comma for all numbers so we can compare as a text string 
              // Todo: correct numeric sort "hack" - now we use 30 digits before comma and 30 after comma and treat as text - should ideally be better handled
            }
            sortkey += key + "\0"
          } // end for each key in range
        }) // end for each keyrange
      } // sortkey filled in
      lines.push({ l: l, k: gC("ic") ? sortkey.toUpperCase() : sortkey })
    })

    // sort lines based on key k in lines array
    gE("otxt").value = lines.sort((a, b) => { let x = a.k, y = b.k; if (gC("inv")) { [x, y] = [y, x] }; return ((x < y) ? -1 : ((x > y) ? 1 : 0)) }).map(l => l.l).join("\n")
  }
  doSetup(run, [10, 100], [10, 100])
</script>

</html>